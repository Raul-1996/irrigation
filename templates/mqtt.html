{% extends "base.html" %}

{% block title %}MQTT Настройки{% endblock %}
{% block page_title %}MQTT Настройки{% endblock %}

{% block extra_css %}
<style>
  .card { background: var(--card-background); border: 1px solid var(--border-color); border-radius: 10px; padding: 1rem; margin-bottom: 1rem; box-shadow: var(--shadow); }
  .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: .9rem; }
  .field { display:flex; flex-direction:column; gap:.35rem; }
  .field label { font-weight: 600; color: var(--text-color); }
  .field input, .field select { padding: .6rem .7rem; border:1px solid var(--border-color); border-radius: 8px; background: #fff; color: #222; box-shadow: inset 0 1px 2px rgba(0,0,0,0.03); }
  .actions { display:flex; gap:.5rem; }
  .servers { margin-top:1rem; }
  table { width:100%; border-collapse: collapse; background: var(--card-background); color: var(--text-color); }
  th, td { border:1px solid var(--border-color); padding:.6rem; text-align:left; color: #222; }
  th { background:#f1f3f5; color:#222; }
  .status-dot { width:10px; height:10px; display:inline-block; border-radius:50%; margin-right:.4rem; box-shadow:0 0 0 2px rgba(0,0,0,.05) inset; }
  .ok { background:#2ecc71; }
  .bad { background:#e74c3c; }
  .btn { padding:.5rem .9rem; border:none; border-radius:6px; cursor:pointer; }
  .btn-primary { background: var(--primary-color); color:white; }
  .btn-danger { background: var(--danger-color); color:white; }
  .btn-secondary { background: #6c757d; color:white; }
  .section-title { color: var(--text-color); margin: .25rem 0 .6rem; }
  .split { display:grid; grid-template-columns: 1fr; gap:1rem; }
  @media (min-width: 900px){ .split { grid-template-columns: 1fr 1fr; } }
  .browser { background: var(--card-background); border: 1px solid var(--border-color); border-radius: 10px; padding: 1rem; box-shadow: var(--shadow); min-height: 360px; }
  .browser-controls { display:flex; gap:.5rem; margin-bottom:.5rem; align-items:center; }
  .browser-log { height: 280px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .85rem; background: #0b1220; color: #e6edf3; border-radius: 8px; padding: .5rem; white-space: pre-wrap; }
  .evt { color:#9cdcfe; }
  .err { color:#f28b82; }
  .tree { background: var(--card-background); border:1px solid var(--border-color); border-radius:10px; padding:.5rem .75rem; max-height: 400px; overflow:auto; }
  .tree ul { list-style:none; padding-left: 1rem; margin:0; }
  .tree li { margin:.15rem 0; color: #fff; }
  .tree .leaf { color:#fff; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.85rem; }
  .toggle { cursor:pointer; user-select:none; margin-right:.35rem; }
  .caret::before { content: '▸'; display:inline-block; margin-right:.25rem; }
  .caret.open::before { content: '▾'; }
  .badge { display:inline-block; padding:.15rem .45rem; border-radius:10px; background:#e9ecef; color:#333; font-size:.75rem; }
</style>
{% endblock %}

{% block content %}
<div class="split">
  <div class="card">
    <h3 class="section-title">Добавить MQTT сервер</h3>
    <div class="grid">
      <div class="field">
        <label>Название</label>
        <input id="m_name" placeholder="WB MQTT">
      </div>
      <div class="field">
        <label>Host</label>
        <input id="m_host" placeholder="127.0.0.1">
      </div>
      <div class="field">
        <label>Port</label>
        <input id="m_port" type="number" value="1883">
      </div>
      <div class="field">
        <label>Username</label>
        <input id="m_user" placeholder="user">
      </div>
      <div class="field">
        <label>Password</label>
        <input id="m_pass" type="password" placeholder="pass">
      </div>
      <div class="field">
        <label>Client ID</label>
        <input id="m_client" placeholder="wb-client-1">
      </div>
      <div class="field">
        <label>Включен</label>
        <select id="m_enabled"><option value="true">Да</option><option value="false">Нет</option></select>
      </div>
    </div>
    <div class="actions" style="margin-top:.5rem;">
      <button class="btn btn-primary" onclick="createServer()">Создать</button>
    </div>
  </div>

  <div class="browser">
    <h3 class="section-title">Браузер топиков <span id="selServer" class="badge">—</span></h3>
    <div class="browser-controls">
      <select id="serverSelect" onchange="onServerChange()"></select>
      <input id="filterInput" placeholder="Фильтр (например: wb/#)" style="flex:1; padding:.5rem; border:1px solid var(--border-color); border-radius:8px;">
      <button class="btn btn-secondary" onclick="toggleSubscribe()" id="subBtn">Подписаться</button>
      <select id="durationSel" title="Время ожидания" style="padding:.45rem; border:1px solid var(--border-color); border-radius:8px;">
        <option value="2">2s</option>
        <option value="3" selected>3s</option>
        <option value="5">5s</option>
        <option value="10">10s</option>
      </select>
      <button class="btn btn-primary" id="scanBtn" onclick="toggleScan()">Сканировать топики</button>
      <button class="btn btn-secondary" onclick="showConnectLogs()">Показать логи подключения</button>
      <button class="btn btn-danger" onclick="clearBrowser()">Очистить</button>
    </div>
    <div class="browser-log" id="topicLog"></div>
    <div style="margin-top:.6rem">
      <h4 class="section-title" style="margin:.25rem 0 .4rem">Дерево топиков</h4>
      <div class="tree" id="topicTree">—</div>
    </div>
  </div>
</div>

<div class="card servers">
  <h3 class="section-title">Серверы</h3>
  <table>
    <thead>
      <tr>
        <th>#</th><th>Название</th><th>Host</th><th>Port</th><th>User</th><th>Client</th><th>Вкл</th><th>Действия</th>
      </tr>
    </thead>
    <tbody id="servers_body"></tbody>
  </table>
</div>

{% endblock %}

{% block extra_js %}
<script>
  async function loadServers() {
    try {
      const res = await api.get('/api/mqtt/servers');
      const tbody = document.getElementById('servers_body');
      tbody.innerHTML = '';
      (res.servers || []).forEach(s => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><span class="status-dot bad" data-id="${s.id}" title="offline"></span>${s.id}</td>
          <td><input value="${s.name || ''}" oninput="this.dataset.v=this.value"></td>
          <td><input value="${s.host || ''}" oninput="this.dataset.v=this.value"></td>
          <td><input type="number" value="${s.port || 1883}" oninput="this.dataset.v=this.value"></td>
          <td><input value="${s.username || ''}" oninput="this.dataset.v=this.value"></td>
          <td><input value="${s.client_id || ''}" oninput="this.dataset.v=this.value"></td>
          <td>
            <select oninput="this.dataset.v=this.value">
              <option value="true" ${s.enabled ? 'selected' : ''}>Да</option>
              <option value="false" ${!s.enabled ? 'selected' : ''}>Нет</option>
            </select>
          </td>
          <td>
            <button class="btn btn-primary" onclick="updateRow(this, ${s.id})">Сохранить</button>
            <button class="btn btn-danger" onclick="deleteServer(${s.id})">Удалить</button>
          </td>
        `;
        tbody.appendChild(tr);
      });
      // Заполняем селектор серверов для браузера топиков
      const select = document.getElementById('serverSelect');
      if (select) {
        select.innerHTML = (res.servers||[]).map(s=>`<option value="${s.id}" data-host="${s.host}" data-port="${s.port}" data-user="${s.username||''}" data-client="${s.client_id||''}">${s.name}</option>`).join('');
        updateSelectedBadge();
      }
      // Обновляем статусы
      updateStatuses();
    } catch (e) {
      showNotification('Ошибка загрузки серверов MQTT', 'error');
    }
  }

  async function createServer() {
    const payload = {
      name: document.getElementById('m_name').value,
      host: document.getElementById('m_host').value,
      port: parseInt(document.getElementById('m_port').value || '1883'),
      username: document.getElementById('m_user').value,
      password: document.getElementById('m_pass').value,
      client_id: document.getElementById('m_client').value,
      enabled: document.getElementById('m_enabled').value === 'true'
    };
    try {
      const res = await api.post('/api/mqtt/servers', payload);
      if (res && res.success) {
        showNotification('Сервер создан', 'success');
        loadServers();
      }
    } catch (e) {
      showNotification('Ошибка создания сервера', 'error');
    }
  }

  async function updateRow(btn, id) {
    const tds = btn.closest('tr').querySelectorAll('td');
    const [_, name, host, port, username, client_id, enabledCell] = tds;
    const payload = {
      name: name.querySelector('input').dataset.v ?? name.querySelector('input').value,
      host: host.querySelector('input').dataset.v ?? host.querySelector('input').value,
      port: parseInt(port.querySelector('input').dataset.v ?? port.querySelector('input').value),
      username: username.querySelector('input').dataset.v ?? username.querySelector('input').value,
      client_id: client_id.querySelector('input').dataset.v ?? client_id.querySelector('input').value,
      enabled: (enabledCell.querySelector('select').dataset.v ?? enabledCell.querySelector('select').value) === 'true'
    };
    try {
      const res = await api.put(`/api/mqtt/servers/${id}`, payload);
      if (res && res.success) {
        showNotification('Сервер обновлён', 'success');
        loadServers();
      }
    } catch (e) {
      showNotification('Ошибка обновления сервера', 'error');
    }
  }

  async function deleteServer(id) {
    if (!confirm('Удалить сервер?')) return;
    try {
      const resp = await fetch(`/api/mqtt/servers/${id}`, { method: 'DELETE' });
      if (resp.status === 204) {
        showNotification('Сервер удалён', 'success');
        loadServers();
      } else {
        showNotification('Не удалось удалить сервер', 'error');
      }
    } catch (e) {
      showNotification('Ошибка удаления сервера', 'error');
    }
  }

  document.addEventListener('DOMContentLoaded', loadServers);
  async function updateStatuses(){
    try{
      const rows = document.querySelectorAll('#servers_body tr');
      for (const row of rows){
        const idCell = row.querySelector('.status-dot');
        if (!idCell) continue;
        const serverId = idCell.getAttribute('data-id');
        try{
          const res = await api.get(`/api/mqtt/${serverId}/status`);
          if (res && res.success){
            idCell.classList.toggle('ok', !!res.connected);
            idCell.classList.toggle('bad', !res.connected);
            idCell.title = res.connected ? 'online' : 'offline';
          }
        }catch(e){}
      }
    }catch(e){}
    setTimeout(updateStatuses, 5000);
  }

  // ===== MQTT Topic Browser (simple client via server polling) =====
  let mqttWS = null; // reserved if ws backend appears later
  let polling = null;
  let subscribed = false;
  let scanning = false;
  let scanTimer = null;
  let lastTopicMap = {}; // topic -> last payload
  let expandedPaths = new Set(); // 'devices/wb-.../controls'
  let sseSource = null; // EventSource
  function buildDisplayRegex(filterStr){
    const raw = (filterStr||'').trim();
    if (!raw) return new RegExp('^\/?devices\/');
    // support MQTT wildcards '+' '#', and user '*' as regex '.*'
    let s = raw;
    // ensure leading '/'
    if (s[0] !== '/') s = '/' + s;
    s = s.replace(/[.*+?^${}()|[\]\\]/g, r=> r==='*' ? r : '\\'+r); // escape regex except '*'
    s = s.replace(/\+/g, '[^/]+').replace(/#/g, '.*').replace(/\*/g, '.*');
    return new RegExp('^\/?' + s.replace(/^\//,'/'));
  }
  function hasMqttWildcards(str){ return /[#+]/.test(str||''); }

  function updateSelectedBadge(){
    const sel = document.getElementById('serverSelect');
    const badge = document.getElementById('selServer');
    if (!sel || !badge) return;
    const opt = sel.options[sel.selectedIndex];
    badge.textContent = opt ? opt.textContent : '—';
  }

  function onServerChange(){
    updateSelectedBadge();
    if (subscribed) startPolling();
  }

  function toggleSubscribe(){
    subscribed = !subscribed;
    document.getElementById('subBtn').textContent = subscribed ? 'Отписаться' : 'Подписаться';
    if (subscribed) startPolling(); else stopPolling();
  }

  function clearBrowser(){
    const log = document.getElementById('topicLog');
    log.textContent = '';
  }

  function appendLog(line){
    const log = document.getElementById('topicLog');
    const atBottom = log.scrollTop + log.clientHeight >= log.scrollHeight - 5;
    log.textContent += (line + '\n\n');
    if (atBottom) log.scrollTop = log.scrollHeight;
  }

  function showConnectLogs(){
    const sel = document.getElementById('serverSelect');
    if (!sel) return;
    const serverId = sel.value;
    const duration = parseFloat(document.getElementById('durationSel').value || '2');
    (async ()=>{
      try{
        const res = await fetch(`/api/mqtt/${serverId}/probe`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({filter:'#', duration})});
        if (res.ok){
          const data = await res.json();
          (data.events||[]).forEach(ev=>appendLog(`% ${ev}`));
          if ((data.items||[]).length===0) appendLog('% no messages in this interval');
        }
      }catch(e){ appendLog('% probe error'); }
    })();
  }

  function buildTreeFromTopics(items){
    const root = {};
    for (const it of items){
      const parts = (it.topic||'').split('/').filter(Boolean);
      let node = root;
      for (let i=0;i<parts.length;i++){
        const p = parts[i];
        node.children = node.children || {};
        node.children[p] = node.children[p] || {};
        if (i === parts.length-1){
          node.children[p].value = it.payload;
        }
        node = node.children[p];
      }
    }
    return root;
  }

  function renderTree(node, container, path=[]){
    const ul = document.createElement('ul');
    const keys = Object.keys(node.children||{}).sort();
    for (const k of keys){
      const li = document.createElement('li');
      const child = node.children[k];
      if (child && child.children){
        const caret = document.createElement('span');
        caret.className = 'toggle caret';
        const currPath = path.concat(k).join('/');
        // restore expanded state
        if (expandedPaths.has(currPath)) caret.classList.add('open');
        caret.onclick = ()=>{
          caret.classList.toggle('open');
          const opened = caret.classList.contains('open');
          if (opened) expandedPaths.add(currPath); else expandedPaths.delete(currPath);
          sub.style.display = opened ? 'block' : 'none';
        };
        li.appendChild(caret);
        const label = document.createElement('span');
        label.textContent = k;
        li.appendChild(label);
        const sub = document.createElement('div');
        sub.style.display = expandedPaths.has(currPath) ? 'block' : 'none';
        renderTree(child, sub, path.concat(k));
        li.appendChild(sub);
      }
      if (child && child.value !== undefined){
        const leaf = document.createElement('div');
        leaf.className = 'leaf';
        leaf.textContent = `${k} = ${child.value}`;
        li.appendChild(leaf);
      }
      ul.appendChild(li);
    }
    container.appendChild(ul);
  }

  function toggleScan(){
    scanning = !scanning;
    document.getElementById('scanBtn').textContent = scanning ? 'Остановить сканирование' : 'Сканировать топики';
    if (scanning) startSSE(); else stopSSE();
  }

  function stopScanLoop(){ if (scanTimer){ clearTimeout(scanTimer); scanTimer=null; } }

  function stopSSE(){ if (sseSource){ sseSource.close(); sseSource=null; } }

  function startSSE(){
    stopSSE();
    const sel = document.getElementById('serverSelect');
    if (!sel) return;
    const serverId = sel.value;
    const uiFilter = document.getElementById('filterInput').value.trim();
    const subFilter = hasMqttWildcards(uiFilter) ? uiFilter : '/devices/#';
    const displayRe = buildDisplayRegex(uiFilter);
    const url = `/api/mqtt/${serverId}/scan-sse?filter=${encodeURIComponent(subFilter)}`;
    sseSource = new EventSource(url);
    sseSource.onmessage = (ev)=>{
      try{
        const it = JSON.parse(ev.data);
        const t = (String(it.topic||''));
        const norm = t.startsWith('/') ? t : ('/' + t);
        if (displayRe.test(norm)){
          lastTopicMap[norm] = it.payload;
          const merged = Object.entries(lastTopicMap).map(([topic,payload])=>({topic,payload}));
          const tree = buildTreeFromTopics(merged);
          const container = document.getElementById('topicTree');
          container.innerHTML='';
          renderTree(tree, container);
        }
      }catch(e){}
    };
    sseSource.addEventListener('ping', ()=>{});
  }

  async function startScanLoop(){
    stopScanLoop();
    const sel = document.getElementById('serverSelect');
    if (!sel) return;
    const serverId = sel.value;
    // подписываемся шире, а фильтруем по devices/wb- клиенстки
    const uiFilter = document.getElementById('filterInput').value.trim();
    const subscribeFilter = hasMqttWildcards(uiFilter) ? uiFilter : '/devices/#';
    const displayRe = buildDisplayRegex(uiFilter);
    const duration = parseFloat(document.getElementById('durationSel').value || '3');
    try{
      const res = await fetch(`/api/mqtt/${serverId}/probe`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({filter: subscribeFilter, duration})});
      if (res.ok){
        const data = await res.json();
        const items = (data.items||[]).map(it=>{
          const t = String(it.topic||'');
          const norm = t.startsWith('/') ? t : ('/' + t);
          return {topic: norm, payload: it.payload};
        }).filter(it=> displayRe.test(it.topic));
        // merge into lastTopicMap (сохраняем только нужные ветки)
        for (const it of items){ lastTopicMap[it.topic]=it.payload; }
        // rebuild tree from map for performance predictability
        const mergedItems = Object.entries(lastTopicMap).map(([topic,payload])=>({topic,payload}));
        const tree = buildTreeFromTopics(mergedItems);
        const container = document.getElementById('topicTree');
        // сохраняем текущее множество раскрытых путей (expandedPaths уже поддерживается caret-ами)
        container.innerHTML='';
        renderTree(tree, container);
        appendLog(''); // пустая строка между порциями
        (data.events||[]).forEach(ev=>appendLog(`% ${ev}`));
      }
    }catch(e){ /* ignore */ }
    if (scanning){ scanTimer = setTimeout(startScanLoop, Math.max(1000, (duration*1000))); }
  }

  async function startPolling(){
    stopPolling();
    const sel = document.getElementById('serverSelect');
    if (!sel) return;
    const serverId = sel.value;
    const topicFilter = document.getElementById('filterInput').value || '#';
    appendLog(`[i] Подписка на ${topicFilter}`);
    // пробный запрос на сервер, чтобы взять retained
    try {
      const duration = parseFloat(document.getElementById('durationSel').value || '3');
      const res = await fetch(`/api/mqtt/${serverId}/probe`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({filter: topicFilter, duration: duration})});
      if (res.ok) {
        const data = await res.json();
        (data.events||[]).forEach(ev=>appendLog(`% ${ev}`));
        (data.items||[]).forEach(it=>appendLog(`${it.topic}: ${it.payload}`));
      }
    } catch(e) {}
    // далее — пассивный режим без постоянной связи, можно повторять вручную нажатием "Подписаться"
    polling = setInterval(async ()=>{}, 60000);
  }

  function stopPolling(){ if (polling){ clearInterval(polling); polling=null; } }
</script>
{% endblock %}


