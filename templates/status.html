{% extends "base.html" %}

{% block title %}Статус{% endblock %}
{% block page_title %}Статус{% endblock %}

{% block extra_css %}
<style>
    /* Общие стили для контрастности */
    body {
        color: #333;
    }
    
    .connection-status {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: #f44336;
        color: white;
        text-align: center;
        padding: 0.5rem;
        font-weight: bold;
        z-index: 1000;
        display: none;
    }
    
    .connection-status.show {
        display: block;
    }
    .connection-status.warn { background: #ff9800; }
    
    .legend {
        background: white;
        border-radius: 8px;
        padding: 0.8rem;
        margin-bottom: 1rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        font-size: 0.85rem;
    }
    
    .legend h4 {
        margin: 0 0 0.5rem 0;
        color: #333;
        font-weight: bold;
        font-size: 0.9rem;
    }
    
    .legend-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.4rem;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.8rem;
        color: #333;
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid #ccc;
        flex-shrink: 0;
    }
    
    .top-bar { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        flex-wrap: wrap; 
        gap: 0.5rem; 
        margin-bottom: 1rem; 
    }
    .info-box { 
        background: white; 
        padding: 0.4rem 0.8rem; 
        border-radius: 5px; 
        box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
        font-size: 0.9rem; 
        text-align: center; 
        flex: 1 1 160px; 
        color: #333;
    }
    .info-box strong {
        color: #333;
    }
    .status-grid { 
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
        gap: 1rem; 
        margin-bottom: 1rem; 
    }
    .card { 
        border-radius: 8px; 
        padding: 0.8rem; 
        color: white; 
        display: flex; 
        flex-direction: column; 
        align-items: center; 
        text-align: center; 
        font-size: 0.9rem; 
        min-height: 180px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .card.waiting { 
        background: linear-gradient(135deg, #4caf50, #45a049); 
        color: white;
    }
    .card.watering { 
        background: linear-gradient(135deg, #2196f3, #1976d2); 
        color: white;
    }
    /* Имитация активности расхода воды: пульсация */
    .card.watering.flow-active { 
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(33,150,243,0.6); }
        70% { box-shadow: 0 0 0 12px rgba(33,150,243,0); }
        100% { box-shadow: 0 0 0 0 rgba(33,150,243,0); }
    }
    .card.error { 
        background: linear-gradient(135deg, #f44336, #d32f2f); 
        color: white;
    }
    .card.postponed { 
        background: linear-gradient(135deg, #9e9e9e, #757575); 
        color: white;
    }
    .group-header { 
        font-size: 1rem; 
        margin-bottom: 0.2rem; 
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .postpone-until { 
        margin: 0.5rem 0; 
        font-style: italic; 
        font-size: 0.85rem; 
        background: rgba(255,255,255,0.2);
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        color: white;
        backdrop-filter: blur(5px);
    }
    .btn-group { 
        display: flex; 
        flex-wrap: wrap; 
        gap: 0.5rem; 
        justify-content: center; 
        margin: 0.2rem 0; 
        width: 100%; 
    }
    .btn-group button { 
        flex: 1 1 120px; 
        padding: 0.3rem 0.4rem; 
        border-radius: 5px; 
        cursor: pointer; 
        font-size: 0.85rem; 
        text-align: center; 
        min-width: 120px; 
        border: 2px solid #fff; 
        transition: all 0.2s;
    }
    .btn-group button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .delay { background: #ffc107; color: #000; border-color: transparent; }
    .cancel-postpone { background: #ff9800; color: #fff; border-color: transparent; }
    .start { background: #4caf50; color: #fff; }
    .stop-group { background: #b71c1c; color: #fff; }
    .continue-group { background: #4caf50; color: #fff; }
    .emergency { 
        background: #d32f2f; 
        color: #fff; 
        padding: 0.6rem 1.2rem; 
        border: none; 
        border-radius: 5px; 
        cursor: pointer; 
        font-size: 0.95rem; 
        margin: 1rem auto; 
        display: block; 
        transition: all 0.2s;
    }
    .emergency:hover {
        background: #b71c1c;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .zones-section {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-top: 1rem;
    }
    /* Временно скрываем колонку "Последний полив" на всех устройствах */
    .col-last-watering { display: none !important; }
    .zones-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    .zones-header h3 {
        color: #333;
        margin: 0;
    }
    .zones-count {
        background: #2196f3;
        color: white;
        padding: 0.3rem 0.8rem;
        border-radius: 15px;
        font-size: 0.9rem;
    }
    .zones-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
        color: #333;
    }
    .zones-table th,
    .zones-table td {
        padding: 0.4rem;
        text-align: left;
        border-bottom: 1px solid #eee;
    }
    .zones-table th {
        background: #f5f5f5;
        font-weight: 600;
        color: #333;
        border-bottom: 2px solid #ddd;
    }
    .zones-table td {
        color: #333;
        background: white;
    }
    .zones-table tr:hover td {
        background: #f9f9f9;
    }
    .indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
    }
    .indicator.on { background: #4caf50; }
    .indicator.off { background: #ccc; }
    .zone-start-btn {
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 3px;
        padding: 0.2rem 0.4rem;
        cursor: pointer;
        font-size: 0.8rem;
    }
    .zone-start-btn:hover {
        background: #45a049;
    }
    .zone-photo {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 40px;
        height: 40px;
        border-radius: 5px;
        overflow: hidden;
        background-color: #f0f0f0;
        cursor: pointer;
    }
    .zone-photo img {
        display: block;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }
    .zone-photo .no-photo {
        font-size: 1.5rem;
        color: #888;
    }
    
    /* Мобильная верстка */
    @media (max-width: 768px) {
        .hide-mobile { display: none; }
        .btn-group button { 
            min-width: 100px; 
            font-size: 0.8rem; 
            padding: 0.4rem 0.3rem;
        }
        .status-grid { grid-template-columns: 1fr; gap: 0.8rem; }
        .card { min-height: 160px; padding: 0.6rem; }
        .top-bar { flex-direction: column; gap: 0.3rem; }
        .info-box { flex: 1 1 auto; width: 100%; }
        .legend-grid { grid-template-columns: 1fr; gap: 0.3rem; }
        .zones-section { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        .zones-table { font-size: 0.75rem; min-width: 640px; }
        .zones-table th, .zones-table td { padding: 0.3rem 0.2rem; }
        .emergency { width: 100%; margin: 0.5rem 0; }
        /* Подписи в ячейках на узких экранах для ясности (убираем подпись у "Следующий полив") */
        .zones-table td.col-photo::before { content: attr(data-label) ": "; font-weight: 600; color: #666; margin-right: 4px; }
    }

    /* Модальное окно для просмотра фотографий */
    .photo-modal {
        display: none; /* показ включаем через JS как flex */
        position: fixed;
        z-index: 1001;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.9);
        align-items: center;
        justify-content: center;
        padding: 0;
    }

    .photo-modal-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        max-width: min(90vw, 720px);
        max-height: 90vh;
    }
    /* Гарантия вписывания фото в экран смартфона */
    .photo-modal img {
        display: block;
        max-width: 95vw;
        max-height: 85vh;
        width: auto;
        height: auto;
        object-fit: contain;
    }

    .photo-modal-actions {
        display: flex;
        justify-content: center;
        margin-top: 0;
    }

    .photo-modal-actions .btn {
        padding: 8px 16px;
        font-size: 1rem;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .photo-modal-actions .btn:hover {
        background-color: #f0f0f0;
    }

    .photo-modal-actions .btn:focus {
        outline: none;
    }
</style>
{% endblock %}

{% block content %}
<!-- Индикаторы статусов соединений -->
<div id="connection-status" class="connection-status">⚠️ Нет связи с сервером. Проверьте подключение.</div>
<div id="mqtt-no-servers" class="connection-status warn">⚠️ Нет ни одного MQTT сервера. Проверьте настройки.</div>
<div id="mqtt-no-connection" class="connection-status warn">⚠️ Нет связи с MQTT сервером. Проверьте подключение.</div>

<div class="top-bar">
    <div class="info-box">
        <strong>Время:</strong> <span id="datetime">—</span>
    </div>
    <div class="info-box" id="temp-box" style="display:none;">
        <strong>Температура:</strong> <span id="temp-value">—</span>°C
    </div>
    <div class="info-box" id="hum-box" style="display:none;">
        <strong>Влажность:</strong> <span id="hum-value">—</span>%
    </div>
    <div class="info-box" id="rain-box" style="display:none;">
        <strong>Датчик дождя:</strong> <span id="rain-value">—</span>
    </div>
</div>

<div class="status-grid" id="groups-container">
    <!-- Группы будут загружены динамически -->
</div>

<!-- Легенда цветов (компактная, под группами) -->
<div class="legend">
    <h4>📋 Легенда статусов</h4>
    <div class="legend-grid">
        <div class="legend-item">
            <div class="legend-color" style="background: #4caf50;"></div>
            <span>Ожидание - готов к поливу</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2196f3;"></div>
            <span>Полив - активно поливается</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9e9e9e;"></div>
            <span>Отложено - полив отложен</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f44336;"></div>
            <span>Ошибка - проблема с системой</span>
        </div>
    </div>
</div>

<div style="display:flex; gap:.5rem; justify-content:center; margin-bottom:.5rem;">
    <button id="emergency-btn" class="emergency">Аварийная остановка</button>
    <button id="resume-btn" class="emergency" style="background:#4caf50; display:none;">Продолжить полив</button>
 </div>

<div class="zones-section">
    <div class="zones-header">
        <h3>Все зоны (<span id="zones-count">0</span>)</h3>
    </div>
    <table class="zones-table">
        <thead>
            <tr>
                <th>Статус</th>
                <th>№</th>
                <th>Действие</th>
                <th>Название</th>
                <th>Тип</th>
                <th>Время</th>
                <th>Группа</th>
                <th class="hide-mobile col-last-watering">Последний полив</th>
                <th>Следующий полив</th>
                <th>Фото</th>
            </tr>
        </thead>
        <tbody id="zones-table-body">
            <!-- Зоны будут загружены динамически -->
        </tbody>
    </table>
</div>

<!-- Модальное окно для просмотра фотографий -->
<div id="photoModal" class="photo-modal">
    <div class="photo-modal-content">
        <img id="photoModalImg" src="" alt="Фото зоны">
        <div class="photo-modal-actions">
            <button class="btn btn-primary" onclick="closePhotoModal()">Закрыть</button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // UI timing helpers
    (function(){
      function nowMs(){ return performance && performance.now ? performance.now() : Date.now(); }
      function logUiTiming(kind, detail, ms){
        try{
          console.log(`[UI Timing] ${kind} ${detail}: ${Math.round(ms)}ms`);
        }catch(e){}
      }
      // Wrap fetch to time control actions
      const _fetch = window.fetch;
      window.fetch = async function(input, init){
        const url = (typeof input === 'string') ? input : (input && input.url) || '';
        const isControl = /\/api\/(zones\/.+\/(mqtt\/)?(start|stop)|groups\/\d+\/(start-from-first|stop)|emergency-(stop|resume)|postpone)/.test(url);
        const t0 = nowMs();
        const resp = await _fetch(input, init);
        const t1 = nowMs();
        if (isControl){ logUiTiming('HTTP', url, t1 - t0); }
        return resp;
      };
      // Time button clicks to response end
      function wireBtnTiming(){
        const btnSelectors = [
          '.zone-start-btn', '#emergency-btn', '#resume-btn',
        ];
        btnSelectors.forEach(sel=>{
          document.querySelectorAll(sel).forEach(btn=>{
            if (btn.__timed) return; btn.__timed = true;
            btn.addEventListener('click', ()=>{ btn.__t0 = nowMs(); }, {capture:true});
          });
        });
        // Generic listener to measure end of network roundtrip via DOM updates
        document.addEventListener('zones-rendered', ()=>{
          try{
            const tNow = nowMs();
            document.querySelectorAll('.zone-start-btn').forEach(b=>{
              if (b.__t0){ logUiTiming('UI', 'zone-toggle->render', tNow - b.__t0); b.__t0 = null; }
            });
          }catch(e){}
        });
      }
      document.addEventListener('DOMContentLoaded', wireBtnTiming);
    })();

    // Загрузка и обновление данных статуса
    let statusData = null;
    let zonesData = [];
    let connectionError = false;
    let mqttNoServers = false;
    let mqttNoConnection = false;
    let envProbeTimer = null;
    let envProbeAttempts = 0;
    
    // Функция обновления времени
    async function updateDateTime() {
        try {
            const r = await fetch('/api/server-time?ts=' + Date.now(), { cache: 'no-store' });
            const j = await r.json();
            if (j && j.now_iso) {
                document.getElementById('datetime').textContent = j.now_iso.replace('T',' ');
                return;
            }
        } catch (e) {}
        const now = new Date();
        const pad = (n)=> String(n).padStart(2,'0');
        const dt = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
        document.getElementById('datetime').textContent = dt;
    }
    
    async function loadStatusData() {
        try {
            statusData = await api.get('/api/status');
            updateStatusDisplay();
            hideConnectionError();
            updateMqttWarnings();
            // Согласуем таблицу зон с карточками групп (мгновенно)
            try { reconcileZoneRowsWithGroupStatus(); } catch(e) {}
        } catch (error) {
            console.error('Ошибка загрузки статуса:', error);
            showConnectionError();
        }
    }
    
    async function loadZonesData() {
        try {
            // 1) Быстрый рендер зон по /api/zones (напрямую через fetch, без обёртки)
            let zonesRespJson = [];
            try {
                const zr = await fetch('/api/zones?ts=' + Date.now(), { cache: 'no-store' });
                zonesRespJson = await zr.json();
            } catch (e) {
                zonesRespJson = [];
            }
            zonesData = Array.isArray(zonesRespJson) ? zonesRespJson : [];
            const tbody = document.getElementById('zones-table-body');
            const existingRows = {};
            tbody.querySelectorAll('tr').forEach(row=>{
                const idCell = row.querySelector('td:nth-child(2)');
                if (idCell) existingRows[idCell.textContent.trim()] = row;
            });
            const filteredZones = (zonesData || []).filter(z=>z.group_id !== 999);
            const frag = document.createDocumentFragment();
            filteredZones.forEach(zone=>{
                const rowId = String(zone.id);
                const row = existingRows[rowId];
                if (row){
                    // только изменившиеся поля
                    const ind = row.querySelector('.indicator');
                    if (ind){ ind.classList.remove('on','off'); ind.classList.add(zone.state); }
                    const btn = row.querySelector('.zone-start-btn');
                    if (btn){
                        btn.textContent = zone.state==='on'?'⏹':'▶';
                        const emergency = !!(statusData && statusData.emergency_stop);
                        const action = emergency ? "showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')" : ("startOrStopZone(" + zone.id + ", '" + zone.state + "')");
                        btn.setAttribute('onclick', action);
                    }
                    if (!row.getAttribute('data-zone-id')) {
                        try { row.setAttribute('data-zone-id', String(zone.id)); } catch(e) {}
                    }
                } else {
                    // создаём новую строку с placeholders для группы и next
                    const tr = document.createElement('tr');
                    const emergency = !!(statusData && statusData.emergency_stop);
                    const action = emergency ? "showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')" : ("startOrStopZone(" + zone.id + ", '" + zone.state + "')");
                    tr.innerHTML = `
                        <td><span class="indicator ${zone.state}"></span></td>
                        <td>${zone.id}</td>
                        <td><button class="zone-start-btn" onclick="${action}">${zone.state==='on' ? '⏹' : '▶'}</button></td>
                        <td>${zone.name}</td>
                        <td>${zone.icon}</td>
                        <td>${zone.duration} мин</td>
                        <td data-group-id="${zone.group_id}">${zone.group_id}</td>
                        <td class="hide-mobile col-last-watering">—</td>
                        <td class="col-next" data-label="Следующий полив">—</td>
                        <td class="col-photo" data-label="Фото">
                            <div class="zone-photo">
                                ${zone.photo_path ? 
                                    `<img src="/api/zones/${zone.id}/photo" alt="Фото зоны ${zone.id}" onclick="showPhotoModal('/api/zones/${zone.id}/photo')" title="Нажмите для просмотра">` :
                                    `<div class="no-photo" title="Нет фото">📷</div>`
                                }
                            </div>
                        </td>`;
                    try { tr.setAttribute('data-zone-id', String(zone.id)); } catch(e) {}
                    frag.appendChild(tr);
                }
            });
            if (frag.childNodes.length) tbody.appendChild(frag);
            document.getElementById('zones-count').textContent = filteredZones.length;
            hideConnectionError();
            // После первичного рендера — синхронизация с актуальным статусом групп
            try { reconcileZoneRowsWithGroupStatus(); } catch(e) {}
            // 2) Подгружаем имена групп без блокировки
            (async()=>{
                try{
                    const groups = await api.get('/api/groups');
                    const nameById = {}; (groups||[]).forEach(g=>{ nameById[g.id]=g.name; });
                    tbody.querySelectorAll('tr').forEach(row=>{
                        const cell = row.querySelector('td:nth-child(7)');
                        if (!cell) return;
                        const gidAttr = cell.getAttribute('data-group-id');
                        const gid = gidAttr ? Number(gidAttr) : Number(cell.textContent.trim());
                        if (nameById[gid]) cell.textContent = nameById[gid];
                    });
                }catch(e){}
            })();
            // 3) Подгружаем next-watering без блокировки
            (async()=>{
                try{
                    const ids = filteredZones.map(z=>z.id);
                    if (!ids.length) return;
                    const resp = await fetch('/api/zones/next-watering-bulk',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({zone_ids: ids})});
                    if (!resp.ok) return;
                    const bulk = await resp.json();
                    const nextMap = {}; (bulk.items||[]).forEach(it=>{ nextMap[it.zone_id]= it.next_datetime || (it.next_watering==='Никогда'?'Никогда': null); });
                    tbody.querySelectorAll('tr').forEach(row=>{
                        const idCell = row.querySelector('td:nth-child(2)');
                        const nextCell = row.querySelector('td:nth-child(9)');
                        if (!idCell || !nextCell) return;
                        const zid = Number(idCell.textContent.trim());
                        if (!(zid in nextMap)) return;
                        const v = nextMap[zid];
                        let txt = '—';
                        if (statusData && statusData.emergency_stop) txt = 'До отмены аварии';
                        else if (v==='Никогда') txt = 'Никогда';
                        else if (v) txt = String(v).replace('T',' ').slice(0,19);
                        nextCell.textContent = txt;
                    });
                }catch(e){}
            })();
        } catch (error) {
            console.error('Ошибка загрузки зон:', error);
            showConnectionError();
        }
    }

    // Быстрая синхронизация строк зон с текущим статусом групп из statusData
    function reconcileZoneRowsWithGroupStatus() {
        try {
            if (!statusData || !statusData.groups || !statusData.groups.length) return;
            const wateringByGroup = {};
            (statusData.groups || []).forEach(g => {
                if (g && g.status === 'watering' && g.current_zone) {
                    wateringByGroup[String(g.id)] = Number(g.current_zone);
                }
            });
            const tbody = document.getElementById('zones-table-body');
            if (!tbody) return;
            const rows = tbody.querySelectorAll('tr');
            rows.forEach(row => {
                try {
                    const idCell = row.querySelector('td:nth-child(2)');
                    const grpCell = row.querySelector('td:nth-child(7)');
                    if (!idCell || !grpCell) return;
                    const zid = Number(idCell.textContent.trim());
                    const gidAttr = grpCell.getAttribute('data-group-id');
                    const gid = gidAttr ? String(Number(gidAttr)) : String(grpCell.textContent.trim());
                    const runningZoneId = wateringByGroup[gid];
                    if (typeof runningZoneId === 'undefined') return;
                    const isOn = (zid === runningZoneId);
                    const ind = row.querySelector('.indicator');
                    if (ind) { ind.classList.remove('on','off'); ind.classList.add(isOn ? 'on' : 'off'); }
                    const btn = row.querySelector('.zone-start-btn');
                    if (btn) {
                        btn.textContent = isOn ? '⏹' : '▶';
                        const emergency = !!(statusData && statusData.emergency_stop);
                        const action = emergency ? "showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')" : ("startOrStopZone(" + zid + ", '" + (isOn ? 'on' : 'off') + "')");
                        btn.setAttribute('onclick', action);
                    }
                } catch(e) {}
            });
        } catch (e) {}
    }
    
    function showConnectionError() {
        if (!connectionError) {
            connectionError = true;
            document.getElementById('connection-status').classList.add('show');
        }
    }
    
    function hideConnectionError() {
        if (connectionError) {
            connectionError = false;
            document.getElementById('connection-status').classList.remove('show');
        }
    }

    function updateMqttWarnings() {
        try {
            const noServers = !statusData || !Number(statusData.mqtt_servers_count || 0);
            const notConnected = !noServers && (statusData && statusData.mqtt_connected === false);
            const elNoServers = document.getElementById('mqtt-no-servers');
            const elNoConn = document.getElementById('mqtt-no-connection');
            if (noServers && !mqttNoServers) { mqttNoServers = true; elNoServers.classList.add('show'); }
            if (!noServers && mqttNoServers) { mqttNoServers = false; elNoServers.classList.remove('show'); }
            if (notConnected && !mqttNoConnection) { mqttNoConnection = true; elNoConn.classList.add('show'); }
            if (!notConnected && mqttNoConnection) { mqttNoConnection = false; elNoConn.classList.remove('show'); }
        } catch (e) {}
    }
    
    function formatSeconds(total) {
        const sec = Math.max(0, Math.floor(total));
        const mm = String(Math.floor(sec / 60)).padStart(2, '0');
        const ss = String(sec % 60).padStart(2, '0');
        return `${mm}:${ss}`;
    }

    function getStatusText(group) {
        if (group.status === 'watering' && group.current_zone) {
            const src = String(group.current_zone_source || '').toLowerCase();
            // Оставляем два статуса: по расписанию, либо вручную (включая удаленно)
            if (src === 'schedule') return 'Полив - активно поливается(по расписанию)';
            return 'Полив - активно поливается(запущено вручную)';
        }
        switch (group.status) {
            case 'waiting': return 'Ожидание - готов к поливу';
            case 'error': return 'Ошибка - проблема с системой';
            case 'postponed': {
                const r = (group.postpone_reason || '').toString();
                if (r === 'rain') return 'Отложено - полив отложен из за дождя';
                if (r === 'manual') return 'Отложено - полив отложен пользователем';
                if (r === 'emergency') return 'Отложено - полив отложен из за аварии';
                return 'Отложено - полив отложен';
            }
            default: return 'Ожидание - готов к поливу';
        }
    }

    async function initGroupTimer(group) {
        const span = document.getElementById(`group-timer-${group.id}`);
        if (!span) return;
        try {
            const res = await fetch(`/api/zones/${group.current_zone}/watering-time?ts=${Date.now()}`, { cache: 'no-store' });
            const data = await res.json();
            if (data && data.success && data.is_watering) {
                span.dataset.remainingSeconds = String(data.remaining_seconds ?? (data.remaining_time * 60));
                span.textContent = formatSeconds(Number(span.dataset.remainingSeconds));
            } else {
                span.dataset.remainingSeconds = '';
                span.textContent = '--:--';
            }
        } catch (e) {
            span.textContent = '--:--';
        }
    }
    
    async function updateStatusDisplay() {
        if (!statusData) return;
        updateDateTime();
        // Температура/влажность: показываем блоки, только если датчики включены
        const tb = document.getElementById('temp-box');
        const hb = document.getElementById('hum-box');
        const tv = document.getElementById('temp-value');
        const hv = document.getElementById('hum-value');
        if (statusData.temperature === null || typeof statusData.temperature === 'undefined') {
            tb.style.display = 'none';
        } else {
            tb.style.display = 'inline-block';
            tv.textContent = (statusData.temperature === 'нет данных') ? 'нет данных' : String(statusData.temperature);
        }
        if (statusData.humidity === null || typeof statusData.humidity === 'undefined') {
            hb.style.display = 'none';
        } else {
            hb.style.display = 'inline-block';
            hv.textContent = (statusData.humidity === 'нет данных') ? 'нет данных' : String(statusData.humidity);
        }
        // Отображение датчика дождя: показывать, только если глобально включен
        (function(){
            const rb = document.getElementById('rain-box');
            const rv = document.getElementById('rain-value');
            const enabled = !!(statusData && statusData.rain_enabled);
            if (!enabled) {
                rb.style.display = 'none';
                return;
            }
            rb.style.display = 'inline-block';
            const s = String(statusData.rain_sensor || '').toLowerCase();
            rv.textContent = (s.indexOf('идёт дожд') !== -1 || s.indexOf('идет дожд') !== -1) ? 'дождь идет' : 'нет дождя';
        })();

        // Быстрый пробник: если сейчас отображается "нет данных", опрашиваем /api/env чаще (до 10 попыток)
        if ((tv.textContent === 'нет данных' || hv.textContent === 'нет данных') && !envProbeTimer) {
            envProbeAttempts = 0;
            envProbeTimer = setInterval(async () => {
                try {
                    envProbeAttempts += 1;
                    const resp = await fetch(`/api/env?ts=${Date.now()}`, { cache: 'no-store' });
                    const js = await resp.json();
                    const val = js && js.values ? js.values : {};
                    if (typeof val.temp !== 'undefined' && val.temp !== null) {
                        tb.style.display = 'inline-block';
                        tv.textContent = String(val.temp);
                    }
                    if (typeof val.hum !== 'undefined' && val.hum !== null) {
                        hb.style.display = 'inline-block';
                        hv.textContent = String(val.hum);
                    }
                    if (tv.textContent !== 'нет данных' && hv.textContent !== 'нет данных') {
                        clearInterval(envProbeTimer); envProbeTimer = null;
                    }
                    if (envProbeAttempts >= 10) { clearInterval(envProbeTimer); envProbeTimer = null; }
                } catch (e) {
                    if (envProbeAttempts >= 10) { clearInterval(envProbeTimer); envProbeTimer = null; }
                }
            }, 1000);
        }
        const container = document.getElementById('groups-container');
        container.innerHTML = '';
        const resumeBtn = document.getElementById('resume-btn');
        if (statusData.emergency_stop) { resumeBtn.style.display = 'inline-block'; } else { resumeBtn.style.display = 'none'; }
        for (const group of statusData.groups) {
            const card = document.createElement('div');
            const flowActive = group.status === 'watering' && Math.random() > 0.3;
            card.className = `card ${group.status} ${flowActive ? 'flow-active' : ''}`;
            const statusText = getStatusText(group);
            // Доп. информация: при поливе — зона и таймер; при отложке — дата/время; при ошибке — текст ошибки; иначе — '—'
            let extraText = '—';
            if (group.status === 'watering' && group.current_zone) {
                extraText = `Зона ${group.current_zone}: осталось <span class="group-timer" id="group-timer-${group.id}" data-group-id="${group.id}" data-zone-id="${group.current_zone}" data-remaining-seconds="">--:--</span>`;
            } else if (group.status === 'postponed' && group.postpone_until) {
                const pu = String(group.postpone_until);
                const reason = String(group.postpone_reason || '').toLowerCase();
                if (reason === 'emergency' || pu.trim().toLowerCase().startsWith('до ')) {
                    extraText = pu;
                } else {
                    extraText = `До ${pu}`;
                }
            } else if (group.status === 'error' && group.error_message) {
                extraText = String(group.error_message);
            }
            const groupButtons = `
                <div class="btn-group">
                    <button class="delay" onclick="delayGroup(${group.id}, 1)">Остановить полив на 1 день</button>
                    <button class="delay" onclick="delayGroup(${group.id}, 2)">Остановить полив на 2 дня</button>
                    <button class="delay" onclick="delayGroup(${group.id}, 3)">Остановить полив на 3 дня</button>
                    ${group.status === 'postponed' && group.postpone_until && !statusData.emergency_stop ? `<button class="cancel-postpone" onclick="cancelPostpone(${group.id})">Продолжить по расписанию</button>` : ''}
                </div>
                <div class="btn-group">
                    <button class="continue-group" onclick="startGroupFromFirst(${group.id})">Запустить полив группы</button>
                    <button class="stop-group" onclick="stopGroup(${group.id})">Остановить полив группы</button>
                </div>`;
            card.innerHTML = `
                <div class="group-header">${group.name}</div>
                <div id="group-status-${group.id}">${statusText}</div>
                <div class="postpone-until">${extraText}</div>
                ${groupButtons}
            `;
            card.id = `group-card-${group.id}`;
            container.appendChild(card);
            if (group.status === 'watering' && group.current_zone) {
                initGroupTimer(group);
            }
        }
    }

    function tickCountdowns() {
        const spans = document.querySelectorAll('.group-timer');
        spans.forEach(span => {
            const val = span.dataset.remainingSeconds;
            if (!val) return;
            let sec = Number(val);
            if (Number.isNaN(sec) || sec <= 0) {
                span.textContent = '00:00';
                span.dataset.remainingSeconds = '';
                // Попросим актуальный статус группы и перерисуем её карточку без полной перезагрузки страницы
                const gid = span.dataset.groupId;
                if (gid) refreshSingleGroup(parseInt(gid, 10));
                return;
            }
            sec = sec - 1;
            span.dataset.remainingSeconds = String(sec);
            span.textContent = formatSeconds(sec);
        });
    }

    async function refreshSingleGroup(groupId) {
        try {
            const resp = await fetch(`/api/status?ts=${Date.now()}`, {cache: 'no-store'});
            const data = await resp.json();
            if (!data || !data.groups) return;
            // Обновим глобальные данные статуса, чтобы кнопки/условия отображались корректно
            statusData = data;
            const group = (data.groups || []).find(g => String(g.id) === String(groupId));
            if (!group) return;
            const card = document.getElementById(`group-card-${group.id}`);
            if (!card) return;
            // Полностью пересоберем содержимое карточки по актуальным данным
            const flowActive = group.status === 'watering' && Math.random() > 0.3;
            card.className = `card ${group.status} ${flowActive ? 'flow-active' : ''}`;
            const statusText = getStatusText(group);
            let extraText2 = '—';
            if (group.status === 'watering' && group.current_zone) {
                extraText2 = `Зона ${group.current_zone}: осталось <span class="group-timer" id="group-timer-${group.id}" data-group-id="${group.id}" data-zone-id="${group.current_zone}" data-remaining-seconds="">--:--</span>`;
            } else if (group.status === 'postponed' && group.postpone_until) {
                const pu2 = String(group.postpone_until);
                const reason2 = String(group.postpone_reason || '').toLowerCase();
                if (reason2 === 'emergency' || pu2.trim().toLowerCase().startsWith('до ')) {
                    extraText2 = pu2;
                } else {
                    extraText2 = `До ${pu2}`;
                }
            } else if (group.status === 'error' && group.error_message) {
                extraText2 = String(group.error_message);
            }
            const groupButtons = `
                <div class="btn-group">
                    <button class="delay" onclick="delayGroup(${group.id}, 1)">Остановить полив на 1 день</button>
                    <button class="delay" onclick="delayGroup(${group.id}, 2)">Остановить полив на 2 дня</button>
                    <button class="delay" onclick="delayGroup(${group.id}, 3)">Остановить полив на 3 дня</button>
                    ${group.status === 'postponed' && group.postpone_until && !statusData.emergency_stop ? `<button class="cancel-postpone" onclick="cancelPostpone(${group.id})">Продолжить по расписанию</button>` : ''}
                </div>
                <div class="btn-group">
                    <button class="continue-group" onclick="startGroupFromFirst(${group.id})">Запустить полив группы</button>
                    <button class="stop-group" onclick="stopGroup(${group.id})">Остановить полив группы</button>
                </div>`;
            card.innerHTML = `
                <div class="group-header">${group.name}</div>
                <div id="group-status-${group.id}">${statusText}</div>
                <div class="postpone-until">${extraText2}</div>
                ${groupButtons}
            `;
            if (group.status === 'watering' && group.current_zone) {
                initGroupTimer(group);
            }
        } catch (e) {}
    }

    // Реакция на события MQTT через SSE для моментального обновления (используется ниже в DOMContentLoaded)

    function handleZoneUpdateFromSse(zoneId, newState) {
        try {
            // Обновим локальные zonesData, чтобы таблица зон была согласованной
            const z = zonesData.find(x => Number(x.id) === Number(zoneId));
            if (z) z.state = newState;
            // Найдём группу и обновим только её карточку
            const groupId = z ? z.group_id : null;
            if (groupId) {
                refreshSingleGroup(groupId);
            } else {
                // Если вдруг не нашли — перезагрузим статус целиком как запасной вариант
                loadStatusData();
            }
        } catch (e) {}
    }
    
    async function updateZonesTable() {
        const tbody = document.getElementById('zones-table-body');
        const countSpan = document.getElementById('zones-count');
        
        tbody.innerHTML = '';
        
        // Фильтруем зоны, исключая группу 999 (БЕЗ ПОЛИВА)
        const filteredZones = zonesData.filter(zone => zone.group_id !== 999);
        
        countSpan.textContent = filteredZones.length;
        
        // Получаем имена групп для отображения вместо чисел
        const groups = await api.get('/api/groups');
        const groupNameById = {};
        groups.forEach(g => { groupNameById[g.id] = g.name; });

        // Загружаем следующий полив одним батчем (значительно быстрее на WB)
        let nextWateringData = [];
        try {
            const response = await fetch('/api/zones/next-watering-bulk', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ zone_ids: filteredZones.map(z=>z.id) })
            });
            const bulk = await response.json();
            nextWateringData = (bulk && bulk.items) ? bulk.items : [];
        } catch (e) {
            nextWateringData = [];
        }
        
        const frag = document.createDocumentFragment();
        filteredZones.forEach(zone => {
            let nextWatering = '—';
            if (statusData.emergency_stop) {
                nextWatering = 'До отмены аварии';
            } else {
                const item = nextWateringData.find(x => x.zone_id === zone.id) || {};
                const nextDT = item.next_datetime;
                if (nextDT) {
                    nextWatering = String(nextDT).replace('T',' ').slice(0,19);
                } else if (item.next_watering === 'Никогда') {
                    nextWatering = 'Никогда';
                }
            }
            const tr = document.createElement('tr');
            
            tr.innerHTML = `
                <td><span class="indicator ${zone.state}"></span></td>
                <td>${zone.id}</td>
                <td><button class="zone-start-btn" onclick="${statusData.emergency_stop ? `showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')` : `startOrStopZone(${zone.id}, '${zone.state}')`}">${zone.state==='on' ? '⏹' : '▶'}</button></td>
                <td>${zone.name}</td>
                <td>${zone.icon}</td>
                <td>${zone.duration} мин</td>
                <td>${groupNameById[zone.group_id] || zone.group_id}</td>
                <td class="hide-mobile col-last-watering">—</td>
                <td class="col-next" data-label="Следующий полив">${nextWatering}</td>
                <td class="col-photo" data-label="Фото">
                    <div class="zone-photo">
                        ${zone.photo_path ? 
                            `<img src="/api/zones/${zone.id}/photo" alt="Фото зоны ${zone.id}" onclick="showPhotoModal('/api/zones/${zone.id}/photo')" title="Нажмите для просмотра">` :
                            `<div class="no-photo" title="Нет фото">📷</div>`
                        }
                    </div>
                </td>
            `;
            
            frag.appendChild(tr);
        });
        tbody.appendChild(frag);
        // Signal render complete for perf
        try{ window.dispatchEvent(new CustomEvent('zones-rendered')); }catch(e){}
    }
    
    // Обработчики действий
    async function delayGroup(groupId, days) {
        try {
            // Блокируем кнопки в карточке группы на время запроса
            const card = document.getElementById(`group-card-${groupId}`);
            if (card) {
                const buttons = card.querySelectorAll('button');
                buttons.forEach(b=>b.disabled=true);
            }
            const response = await api.post('/api/postpone', {
                group_id: groupId,
                days: days,
                action: 'postpone'
            });
            
            if (response.success) {
                showNotification(response.message, 'success');
                // Точечно обновляем карточку группы и строки зон этой группы
                await refreshSingleGroup(groupId);
                await refreshZonesRowsForGroup(groupId);
            } else {
                showNotification(response.message, 'error');
            }
        } catch (error) {
            console.error('Ошибка при отложке полива:', error);
            showNotification('Ошибка при отложке полива', 'error');
        } finally {
            const card = document.getElementById(`group-card-${groupId}`);
            if (card) {
                const buttons = card.querySelectorAll('button');
                buttons.forEach(b=>b.disabled=false);
            }
        }
    }
    
    async function cancelPostpone(groupId) {
        try {
            // Блокируем кнопки в карточке группы на время запроса
            const card = document.getElementById(`group-card-${groupId}`);
            if (card) {
                const buttons = card.querySelectorAll('button');
                buttons.forEach(b=>b.disabled=true);
            }
            const response = await api.post('/api/postpone', {
                group_id: groupId,
                action: 'cancel'
            });
            
            if (response.success) {
                showNotification(response.message, 'success');
                // Точечно обновляем карточку группы и строки зон этой группы
                await refreshSingleGroup(groupId);
                await refreshZonesRowsForGroup(groupId);
            } else {
                showNotification(response.message, 'error');
            }
        } catch (error) {
            console.error('Ошибка при отмене отложенного полива:', error);
            showNotification('Ошибка при отмене отложенного полива', 'error');
        } finally {
            const card = document.getElementById(`group-card-${groupId}`);
            if (card) {
                const buttons = card.querySelectorAll('button');
                buttons.forEach(b=>b.disabled=false);
            }
        }
    }
    
    async function startGroupFromFirst(groupId) {
        try {
            const grp = (statusData && statusData.groups ? statusData.groups : []).find(g => String(g.id) === String(groupId));
            const gname = grp && grp.name ? grp.name : groupId;
            const res = await fetch(`/api/groups/${groupId}/start-from-first`, { method: 'POST' });
            const data = await res.json();
            if (data && data.success) {
                showNotification(`Группа "${gname}": ${data.message || 'запущена'}`, 'success');
                await loadStatusData();
                await loadZonesData();
            } else {
                showNotification(data.message || `Ошибка запуска группы "${gname}"`, 'error');
            }
        } catch (error) {
            showNotification('Ошибка при запуске полива группы', 'error');
        }
    }
    
    async function stopGroup(groupId) {
        try {
            const grp = (statusData && statusData.groups ? statusData.groups : []).find(g => String(g.id) === String(groupId));
            const gname = grp && grp.name ? grp.name : groupId;
            if (!confirm(`Остановить полив группы "${gname}"?`)) return;
        } catch (e) {
            if (!confirm(`Остановить полив группы ${groupId}?`)) return;
        }
        
        try {
            const res = await fetch(`/api/groups/${groupId}/stop`, { method: 'POST' });
            const data = await res.json();
            if (data && data.success) {
                showNotification(data.message, 'success');
                await loadStatusData();
                await loadZonesData();
            } else {
                showNotification(data.message || 'Ошибка остановки группы', 'error');
            }
        } catch (error) {
            showNotification('Ошибка при остановке группы', 'error');
        }
    }
    
    async function startOrStopZone(zoneId, currentState) {
        try {
            // Находим группу зоны
            const idx = zonesData.findIndex(z => z.id === zoneId);
            if (idx < 0) return;
            const zone = zonesData[idx];
            const groupId = zone.group_id;
            const wantOn = currentState !== 'on';
            // Оптимистическое обновление UI: переключим состояние сразу
            zonesData[idx].state = wantOn ? 'on' : 'off';
            // Мгновенно обновим строку зоны в таблице (индикатор и кнопка)
            try {
                const tbody = document.getElementById('zones-table-body');
                if (tbody) {
                    let row = tbody.querySelector(`tr[data-zone-id="${zoneId}"]`);
                    if (!row) {
                        const rows = tbody.querySelectorAll('tr');
                        rows.forEach(r => {
                            const cells = r.querySelectorAll('td');
                            if (cells.length > 1 && Number(cells[1].textContent.trim()) === zoneId) {
                                row = r;
                            }
                        });
                    }
                    if (row) {
                        const ind = row.querySelector('.indicator');
                        if (ind) { ind.classList.remove('on','off'); ind.classList.add(wantOn ? 'on' : 'off'); }
                        const btn = row.querySelector('.zone-start-btn');
                        if (btn) {
                            btn.textContent = wantOn ? '⏹' : '▶';
                            const emergency = !!(statusData && statusData.emergency_stop);
                            const action = emergency ? "showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')" : ("startOrStopZone(" + zoneId + ", '" + (wantOn ? 'on' : 'off') + "')");
                            btn.setAttribute('onclick', action);
                        }
                    }
                }
            } catch (e) {}
            if (groupId) {
                // Обновим карточку группы и строки зон этой группы без полной перезагрузки
                refreshSingleGroup(groupId);
                refreshZonesRowsForGroup(groupId);
            }
            const url = wantOn ? `/api/zones/${zoneId}/mqtt/start` : `/api/zones/${zoneId}/mqtt/stop`;
            const res = await fetch(url, { method: 'POST' });
            let data = null;
            try { data = await res.json(); } catch(e) { data = null; }
            if (res.ok && data && data.success) {
                showNotification(data.message || (wantOn?'Зона запущена':'Зона остановлена'), 'success');
                // Подтянем актуальные данные для всей страницы без полной перезагрузки
                await refreshAllUI();
            } else {
                const msg = (data && data.message) ? data.message : (wantOn?'Ошибка запуска зоны':'Ошибка остановки зоны');
                showNotification(msg, 'error');
                // Откат оптимистического состояния
                zonesData[idx].state = currentState;
                await refreshAllUI();
            }
        } catch (error) {
            showNotification('Ошибка управления зоной', 'error');
        }
    }
    
    async function emergencyStop() {
        if (!confirm('Аварийная остановка всех зон?')) return;
        
        try {
            const res = await fetch('/api/emergency-stop', { method: 'POST' });
            const data = await res.json();
            if (data && data.success) {
                showNotification(data.message, 'warning');
                await loadStatusData();
                await loadZonesData();
                // Показать кнопку возобновления явно
                document.getElementById('resume-btn').style.display = 'inline-block';
            } else {
                showNotification(data.message || 'Ошибка аварийной остановки', 'error');
            }
        } catch (error) {
            showNotification('Ошибка при аварийной остановке', 'error');
        }
    }

    async function resumeSchedule() {
        try {
            const res = await fetch('/api/emergency-resume', { method: 'POST' });
            const data = await res.json();
            if (data && data.success) {
                showNotification(data.message, 'success');
                await loadStatusData();
                await loadZonesData();
                // Скрыть кнопку возобновления
                document.getElementById('resume-btn').style.display = 'none';
            } else {
                showNotification(data.message || 'Ошибка возобновления полива', 'error');
            }
        } catch (error) {
            showNotification('Ошибка возобновления полива', 'error');
        }
    }

    async function refreshAllUI() {
        try {
            await loadStatusData();
            await loadZonesData();
        } catch (e) {}
    }

    // Модальное окно для просмотра фотографий
    function showPhotoModal(photoUrl) {
        const img = document.getElementById('photoModalImg');
        img.src = photoUrl;
        const modal = document.getElementById('photoModal');
        modal.style.display = 'flex'; // чтобы сработало центрирование по flex
    }

    function closePhotoModal() {
        document.getElementById('photoModal').style.display = 'none';
    }
    
    // Инициализация
    document.addEventListener('DOMContentLoaded', () => {
        // Обновляем время сразу
        updateDateTime();
        
        loadStatusData();
        loadZonesData();
        
        // Обновление времени каждую секунду
        setInterval(updateDateTime, 1000);
        
        // Обновление данных каждые 30 секунд
        setInterval(() => {
            loadStatusData();
            loadZonesData();
        }, 30000);
        setInterval(tickCountdowns, 1000);
        
        // Обработчик аварийной остановки
        document.getElementById('emergency-btn').addEventListener('click', emergencyStop);
        document.getElementById('resume-btn').addEventListener('click', resumeSchedule);
        // Подписка на статусы зон через SSE
        try {
            const es = new EventSource('/api/mqtt/zones-sse');
            es.onmessage = (ev)=>{
                try{
                    const data = JSON.parse(ev.data);
                    const idx = zonesData.findIndex(z=>z.id===data.zone_id);
                    if (idx>=0){
                        zonesData[idx].state = data.state;
                        // Обновим карточку соответствующей группы, чтобы строка "Полив — Зона X" сменилась мгновенно
                        const gid = zonesData[idx].group_id;
                        if (gid) { refreshSingleGroup(gid); }
                        const tbody = document.getElementById('zones-table-body');
                        if (tbody){
                            let row = tbody.querySelector(`tr[data-zone-id="${data.zone_id}"]`);
                            if (!row) {
                                const rows = tbody.querySelectorAll('tr');
                                rows.forEach(r=>{
                                    const cells = r.querySelectorAll('td');
                                    if (cells.length>1 && Number(cells[1].textContent.trim())===data.zone_id){ row = r; }
                                });
                            }
                            if (row){
                                const ind = row.querySelector('.indicator');
                                if (ind){ ind.classList.remove('on','off'); ind.classList.add(data.state); }
                                const btn = row.querySelector('.zone-start-btn');
                                if (btn){
                                    btn.textContent = data.state==='on'?'⏹':'▶';
                                    const emergency = !!(statusData && statusData.emergency_stop);
                                    const action = emergency ? "showNotification('Аварийная остановка активна. Сначала отключите режим.', 'warning')" : ("startOrStopZone(" + data.zone_id + ", '" + data.state + "')");
                                    btn.setAttribute('onclick', action);
                                }
                            }
                        }
                    }
                }catch(e){}
            };
        } catch (e) {}
    });

    // Точечное обновление строк зон группы (без полной перерисовки таблицы)
    async function refreshZonesRowsForGroup(groupId) {
        try {
            const tbody = document.getElementById('zones-table-body');
            if (!tbody) return;
            const zonesForGroup = (zonesData || []).filter(z => String(z.group_id) === String(groupId));
            const promises = zonesForGroup.map(async (zone) => {
                try {
                    const resp = await fetch(`/api/zones/${zone.id}/next-watering`, { cache: 'no-store' });
                    const data = await resp.json();
                    let nextText = '—';
                    if (data && data.next_datetime) {
                        nextText = String(data.next_datetime).replace('T',' ').slice(0,19);
                    } else if (data && data.next_watering === 'Никогда') {
                        nextText = 'Никогда';
                    }
                    // Найти строку зоны по её № (вторая колонка)
                    const rows = tbody.querySelectorAll('tr');
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 9) {
                            const idCell = cells[1];
                            if (idCell && String(idCell.textContent.trim()) === String(zone.id)) {
                                // Колонка "Следующий полив" — девятая (index 8)
                                const nextCell = cells[8];
                                if (nextCell) nextCell.textContent = nextText;
                            }
                        }
                    });
                } catch (e) { /* ignore single zone error */ }
            });
            await Promise.all(promises);
        } catch (e) { /* ignore group update error */ }
    }
</script>
{% endblock %}
